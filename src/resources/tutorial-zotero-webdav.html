        <div class="position-relative page-width-1 page-center">
          <div class="tm-bg-dark content-pad">
            <h1 class="mb-5">How to setup a Zotero WebDAV server with a Raspberry Pi</h1>
            <p>
              There are quite a few options now for reference management software, but Zotero has always been
              the only completely free option. One under-appreciated feature is that if you
              want a synchronised PDF library across several workstations, Zotero will allow
              you to do that by letting you use your own
              WebDAV server. Problem: how does one make a WebDAV server?
            </p>
            <p>
              This tutorial essentially has this goal in mind: create a WebDAV server that will work with Zotero all the
              time with no concerns about disk space and <em>no running cost</em>.
              Now, here's the catch: to have a server running <em>all the time</em>, the best option is really to buy a
              <a class="a-no-underline" target="_blank"
                 href="https://www.raspberrypi.com/products/raspberry-pi-4-model-b/">
                Raspberry Pi
              </a>,
              configure it as a WebDAV server and leave it running in a corner of your house/workplace. You get the
              overhead cost of a yearly subscription of paperpile for a lifetime supply of the same service.
              Another point, since we don't want to buy a domain and subscribe to a DNS service, we will use our public
              IP as the domain name for connecting via the internet, but there's no real downside to that since this is
              for private use.
            </p>

            <h2 class="mt-5 mb-5"> 1. Setup the Raspberry Pi</h2>

            <h4 class="mt-5 mb-5 ms-5">Hardware</h4>
            <p>At first you will obviously need a screen, keyboard and mouse plugged into the Pi. Then, you can connect to your network (ethernet or wifi) and set up some remote-control software, such as VNC Viewer or SSH to control the Pi directly through a remote terminal. At this point you can essentially leave the Pi as such with just the power supply plugged, and the ethernet cable if you chose that method over wifi.</p>

            <h4 class="mt-5 mb-5 ms-5">Basic Software</h4>
            <p>Let's properly setup the Raspberry Pi OS first. This section is based on
              <a class="a-no-underline" target="_blank" href="https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-20-04">
              this tutorial</a>, except we do not touch on setting up the SSH protocol. But feel free to look into it as well if you want to of course.
            </p>
            <p>Let's first update the system to its latest version. In a terminal, enter the following:</p>
            <div class="code-block"><code><ul>
              <li>sudo apt-get update</li>
              <li>sudo apt-get dist-upgrade</li>
              <li>sudo apt-get autoremove</li>
            </ul></code></div>
            <p>Next, we will setup a regular user profile, and then grant that profile superuser privileges.</p>
            <div class="code-block"><code><ul>
              <li>adduser your_user_name</li>
              <li>usermod -aG sudo your_user_name</li>
            </ul></code></div>
            <p>Now log in as your_user_name. This manipulation allows you to have superuser privileges when you want to
              by typing <code>sudo</code> before any command, but you won't have any superuser privilege if you omit it.
              This way of setting up user privileges is generally good practice to avoid doing any accidental damage to
              the system following an unfortunate command.
            </p>
            <p>And finally, we need to setup a firewall.</p>
            <div class="code-block"><code><ul>
              <li>ufw enable</li>
            </ul></code></div>

            <h2 class="mt-5 mb-5"> 2. Create a WebDAV server using the HTTP protocol</h2>
            <p>This section is based on step 2 of
              <a class="a-no-underline" target="_blank"
                 href="https://www.digitalocean.com/community/tutorials/how-to-configure-webdav-access-with-apache-on-ubuntu-14-04#step-two-%E2%80%94-setting-up-webdav">
                this tutorial
              </a>
              for creating the WebDAV server and step 5 of
              <a class="a-no-underline" target="_blank"
                 href="https://www.digitalocean.com/community/tutorials/how-to-install-the-apache-web-server-on-ubuntu-20-04#step-5-%E2%80%94-setting-up-virtual-hosts-recommended">
                that tutorial
              </a>
              for creating the virtual host.
              A virtual host is essentially a configuration profile for the WebDAV server that is specific to
              a user-defined set of directories. This allows us to create different websites with different
              configurations on the same machine (Raspberry Pi).
            </p>
            <p>First, we will need to install
              <a class="a-no-underline" target="_blank"
                 href="https://ubuntu.com/server/docs/web-servers-apache">apache2
              </a>,
              which is the most common package to create WebDAV servers on linux systems.
            </p>
            <div class="code-block"><code><ul>
              <li>sudo apt-get update</li>
              <li>sudo apt-get install apache2</li>
            </ul></code></div>
            <p>
              Next we create the directory in which the WebDAV server will live, and give ownership of that directory
              to the apache user so that it is allowed to manage it.
            </p>
            <div class="code-block"><code><ul>
              <li>sudo mkdir /var/www/webdav</li>
              <li>sudo chown -R www-data:www-data /var/www/</li>
            </ul></code></div>
            <p>And we activate the <code>a2enmod</code> shell script and use it to activate the WebDAV modules.</p>
            <div class="code-block"><code><ul>
              <li>enable a2enmod</li>
              <li>sudo a2enmod dav</li>
              <li>sudo a2enmod dav_fs</li>
            </ul></code></div>
            <p>
              Next, we need to create a configuration file for our server. In Apache, configuration files are stored
              in <code>/etc/apache2/sites-available/</code>. Several files can be stored there depending on how many
              websites your machine hosts. The default configuration file is <code>000-default.conf</code>.
            </p>
            <p>
              Let's create our own configuration file, called <code>webdav.conf</code>. To edit files in Linux, I use
              nano, but feel free to use whatever editor you prefer. If you're unsure, nano is usually a solid choice as
              it is simpler to use.
            </p>
            <div class="code-block"><code><ul>
              <li>sudo nano /etc/apache2/sites-available/webdav.conf</li>
            </ul></code></div>
            <p>
              In this file, copy and paste the content below.
            </p>
            <div class="accordion">
              <div class="accordion-item">
                <h2 class="accordion-header bg-gradient">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#conffileHTTP">
                    <code>/etc/apache2/zites-available/webdav.conf</code>
                  </button>
                </h2>
                <div id="conffileHTTP" class="accordion-collapse show">
                  <div class="accordion-body bg-transparent">
                    <pre><code>
DavLockDB /var/www/DavLock
&lt;VirtualHost *:80&gt;
    ServerAdmin your_email_here
    DocumentRoot /var/www/html

    ErrorLog ${APACHE_LOG_DIR}/error.log
    CustomLog ${APACHE_LOG_DIR}/access.log combined

    Alias /webdav /var/www/webdav

    &lt;Directory /var/www/webdav&gt;
        DAV On
    &lt;/Directory&gt;
&lt;/VirtualHost&gt;

# vim: syntax=apache ts=4 sw=4 sts=4 sr noet
                    </code></pre>
                  </div>
                </div>
              </div>
            </div>
            <p>
              To save and close the file, press <code>CTRL + X</code>, then <code>y</code> for "yes", and finally press
              "enter".
            </p>
            <p>
              You can find details about what each line in the configuration file means
              <a class="a-no-underline" target="_blank"
                 href="https://www.digitalocean.com/community/tutorials/how-to-configure-webdav-access-with-apache-on-ubuntu-14-04#step-two-%E2%80%94-setting-up-webdav">
                here
              </a>.
              Essentially, we are indicating that the website is on port 80 of the router (usual port for HTTP protocol), and
              pointing out the root location of the website on the system, which means when you call your public IP on a browser,
              the server will display <code>/var/www/html/index.html</code>. The <code>Alias</code> line means that
              when you call <code>http://your_ip_here/webdav</code>, the server will display <code>/var/www/webdav</code>.
              The <code>DAV On</code> line simply toggles the WebDAV service on for the assigned directory, so <code>/var/www/webdav</code>
              will behave like a WebDAV folder rather than a normal website.
            </p>
            <p>Next, we disable the default configuration file and enable our WebDAV configuration file</p>
            <div class="code-block"><code><ul>
              <li>sudo a2dissite 000-default.conf</li>
              <li>sudo a2ensite webdav.conf</li>
            </ul></code></div>
            <p>We can test that the configuration file has been set up properly using a built-in tool from the apache2 package</p>
            <div class="code-block"><code><ul>
              <li>sudo apache2ctl configtest</li>
            </ul></code></div>
            <p>
              If everything is set up properly we should get a <code>Syntax OK</code> output. You may also see this
              error: <code>AH00558: Could not reliably determine the server's fully qualified domain name</code>.
              This should not be a problem for what we are trying to do, but you can see
              <a class="a-no-underline" target="_blank"
                 href="https://www.digitalocean.com/community/tutorials/how-to-install-the-apache-web-server-on-ubuntu-20-04#step-6-%E2%80%93-getting-familiar-with-important-apache-files-and-directories">
                here
              </a>
              for how to fix it if you want to.
            </p>
            <p>
              Finally, set a port-forwarding rule in your router to link the port 80 to your Raspberry Pi's private
              IP address. Open your favorite browser, type in <code>192.168.0.1</code> and login to your router. If you
              are not sure how to do it, this usually depends on the internet service provider who provided the internet
              box of your house. Find out the brand and check on your ISP's website what is the default login.

              Navigate to the port-forwarding tab of your router interface and create a new rule:
            </p>
            <ul>
              <li><strong>Common Application:</strong> -SERVICES-</li>
              <li><strong>Application Name:</strong> whatever_you_want</li>
              <li><strong>Protocol:</strong> TCP</li>
              <li><strong>Public Port Range:</strong> 80-80</li>
              <li><strong>Private Port Range:</strong> 80-80</li>
              <li><strong>Local IP Address:</strong>
                The local IP address of your Raspberry Pi. You can retrieve it by entering <code>
                hostname -I | awk '{print $1}'</code> in your machine's terminal</li>
              <li><strong>
                Remote IP Address:</strong>
                "Any", or if you plan to connect only from a defined set of IP locations you can
                specify those to increase security.</li>
              <li><strong>Rule Status:</strong> ON</li>
            </ul>
            <p>Restart apache:</p>
            <div class="code-block"><code><ul>
              <li>sudo systemctl restart apache2</li>
            </ul></code></div>
            <p>You should now be able to access the server online at <code>http://your_ip_here/webdav/</code></p>

            <h2 class="mt-5 mb-5"> 3. Create a WebDAV server using the HTTPS protocol</h2>
            <h4 class="mt-5 mb-5 ms-5">Configure the firewall</h4>
            <p>
              As indicated above, depending on your version of apache, your firewall could list the apache-related
              applications as "WWW" or "Apache". To check this out, type <code>sudo ufw app list</code> in a terminal to
              see if the list contains <code>WWW</code>, <code>WWW Full</code> and <code>WWW Secure</code>, or
              <code>Apache</code>, <code>Apache Full</code> and <code>Apache Secure</code>. From here onward, I will
              assume that your firewall uses <code>WWW</code> but please swap <code>WWW</code> for <code>Apache</code>
              if you need to.
            </p>
            <p>
              Let's change the firewall rules to allow for both HTTP and HTTPS communication, and disable the rule for
              HTTP-only communication.
            </p>
            <div class="code-block"><code><ul>
                <li>sudo ufw allow "WWW Full"</li>
                <li>sudo ufw disable allow "WWW"</li>
            </ul></code></div>
            <p>Next we enable apache's <code>mod_ssl</code> module and restart apache to apply the changes.</p>
             <div class="code-block"><code><ul>
                <li>sudo a2enmod ssl</li>
                <li>sudo systemctl restart apache2</li>
            </ul></code></div>

            <h4 class="mt-5 mb-5 ms-5">Edit the configuration file</h4>
            <p>We then edit our <code>webdav.conf</code> file, so its content looks like this eventually</p>

            <div class="accordion">
              <div class="accordion-item">
                <h2 class="accordion-header bg-gradient">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#conffileHTTPS">
                    <code>/etc/apache2/zites-available/webdav.conf</code>
                  </button>
                </h2>
                <div id="conffileHTTPS" class="accordion-collapse show">
                  <div class="accordion-body bg-transparent">
                    <pre><code>
DavLockDB /var/www/DavLock
&lt;VirtualHost *:443&gt;
    ServerAdmin your_email_here
    ServerName your_ip_here
    DocumentRoot /var/www/html

    SSLCertificateFile /etc/ssl/zotero_webdav.crt
    SSLCertificateKeyFile /etc/ssl/zotero_webdav.key

    ErrorLog ${APACHE_LOG_DIR}/error.log
    CustomLog ${APACHE_LOG_DIR}/access.log combined

    Alias /webdav /var/www/webdav

    &lt;Directory /var/www/webdav&gt;
        DAV On
    &lt;/Directory&gt;
&lt;/VirtualHost&gt;

# vim: syntax=apache ts=4 sw=4 sts=4 sr noet
                    </code></pre>
                  </div>
                </div>
              </div>
            </div>
            <p>As a reminder, the terminal command for that purpose (if you use the nano editor) is:</p>
             <div class="code-block"><code><ul>
                <li>sudo nano /etc/apache2/zites-available/webdav.conf</li>
            </ul></code></div>
            <p>
              Note that on the second line, the virtual host is now 443 and not 80 anymore. Finally, we check that the
              syntax is correct and restart the apache server to apply the changes.
            </p>
            <div class="code-block"><code><ul>
              <li>sudo apache2ctl configtest</li>
              <li>sudo systemctl restart apache2</li>
            </ul></code></div>


            <h4 class="mt-5 mb-35ms-5">Set up the port forwarding rule</h4>
            <p>
              We must now add a new port forwarding rule on the router for port 443. It's the exact same thing as when
              we set up the rule for the HTTP protocol above, except that we replace all the 80-80 port ranges with
              443-443. Please keep the port 80 rule on as well, it will be useful for when we enable HTTP-to-HTTPS transfer
              below.
            </p>

            <h4 class="mt-5 mb-5 ms-5">Get a SSL certificate for the WebDAV server</h4>
            <p>
              Now we need a SSL certificate for the HTTPS protocol to actually work properly. See the introduction of
              <a class="a-no-underline" target="_blank"
                 href="https://www.digitalocean.com/community/tutorials/how-to-create-a-self-signed-ssl-certificate-for-apache-in-ubuntu-18-04">
                 this tutorial
              </a>
              for an explanation of what a SSL certificate is and why we need one.
            </p>
            <p>
              Usually, SSL certificates are provided by third parties called Certificate Authority (CA). Now, the issue
              with CAs is that they don't all provide certificates for bare IP addresses, and those that do (e.g.
              <a class="a-no-underline" target="_blank"
                 href="https://zerossl.com/">
                 ZeroSSL
              </a>)
              require a subscription. So instead we're going to use a self-signed certificate. Those are usually not
              trusted online because they essentially signal that the website has been "vetted" by the person who controls
              the website rather than by an independent authority (the CA). This matters since most websites are not
              visited by the website owner but by the general public, but for us this doesn't matter as the WebDAV
              server is for private use only.
            </p>
            <p>
              Now certificates expire after a while, specifically a year or 90 days depending on what you chose when
              you request it. This is for the same reason as why we should change our password regularly, to ensure a more
              secure encryption over time. Consequently, 90-days certificate tend to be better than 1-year
              certificates.
            </p>
            <p>First, let's ensure the recipient directories for the certificate exist.</p>
            <div class="code-block"><code><ul>
              <li>sudo mkdir /etc/ssl/certs/</li>
              <li>sudo mkdir /etc/ssl/private/</li>
            </ul></code></div>
            <p>
              Next, let's request the certificate using
              <a class="a-no-underline" target="_blank" href="https://www.openssl.org/">OpenSSL</a>,
              which should come pre-installed with most linux. If not, you may have to install it.
            </p>
            <div class="code-block"><code><ul>
              <li>sudo apt-get install openssl</li>
              <li>sudo openssl req -x509 -nodes -days &lt;365-or-90&gt; -newkey rsa:2048 -keyout /etc/ssl/private/zotero_webdav.key -out /etc/ssl/certs/zotero_webdav.crt</li>
              <li>sudo systemctl restart apache2</li>
            </ul></code></div>
            <p>
              Don't foget to pick a choice for the <code>-days</code> option.
              Fill in all the information (the Common Name should be <code>your_ip_address</code>).
              Once this is done, you should be able to access your server online using the HTTPS protocol at
              <code>https://your_ip_here</code>. Your browser will most likely warn that the SSL certificate is
              self-signed. You can tell it to ignore this warning, which will add the SSL certificate for your server
              to the browser's whitelist.
            </p>

            <h4 class="mt-5 mb-5 ms-5">Automatic renewal of the SSL certificate</h4>
            <p>
              Linux systems come with a package called CRON for automatically running commands and programs.
              This is what we're going to use here. The below example is set to renew the SSL certificate every 89 days
              at 5:00 AM. That's one less than 90 days to avoid "off" time between certificates, since the CRON job is set
              to run once a day. If you want to renew every 364 because you installed a 365-days SSL certificate,
              replace <code>0 5 */89 * *</code> by <code>0 5 */364 * *</code> in the code snippet below. Also, don't
              forget to include the information such as Common Name, City, Country, etc in the <code>openssl</code>
              command.
            </p>
            <div class="code-block"><code><ul>
              <li>cd ~/Documents  # to make sure we're in a directory with write access</li>
              <li>sudo crontab -l > mycron # write out current crontab</li>
              <li># echo new cron into cron file</li>
              <li>echo "0 5 */89 * * sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048
                -subj "/C=&lt;Country Code>/ST=&lt;State&gt;/L=&lt;City&gt;/O=&lt;Organization&gt;/CN=&lt;your_ip_here&gt;"
                -keyout /etc/ssl/private/zotero_webdav.key
                -out /etc/ssl/certs/zotero_webdav.crt
                && sudo systemctl restart apache2" >> mycron</li>
              <li># install new cron file and remove tmp file</li>
              <li>sudo crontab mycron</li>
              <li>rm mycron</li>
            </ul></code></div>
            <p>Done!</p>

            <h4 class="mt-5 mb-5 ms-5">HTTP to HTTPS transfer</h4>
            <p>
              Now to be able to access the website at <code>https://</code> with the <code>http</code> address, add
              this at the bottom of <code>webdav.conf</code> (before the last line):
            </p>
            <pre><code>
&lt;VirtualHost *:80&gt;
    ServerName your_ip_here
    Redirect / https://your_ip_here/
&lt;/VirtualHost&gt;
            </code></pre>
            <p>Then run in a terminal<p>
            <div class="code-block"><code><ul>
              <li>sudo apachectl configtest</li>
              <li>sudo systemctl reload apache2</li>
            </ul></code></div>
            <p>
              Then you can test this online by connecting to your website with either the <code>http://</code> or
              <code>https</code> prefix.
            </p>

            <h2 class="mt-5 mb-5">4. Adding authentication</h2>
            <p>
              Just follow step 3 of
              <a class="a-no-underline" target="_blank"
                 href="https://www.digitalocean.com/community/tutorials/how-to-configure-webdav-access-with-apache-on-ubuntu-14-04">
                this tutorial.
              </a>
              The only difference is that we will edit <code>/etc/apache2/sites-available/webdav.conf</code> instead of
              <code>/etc/apache2/sites-available/000-default.conf</code>. Our configuration file now looks like this:
            </p>
                          <div class="accordion">
              <div class="accordion-item">
                <h2 class="accordion-header bg-gradient">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#conffile_auth">
                    <code>/etc/apache2/zites-available/webdav.conf</code>
                  </button>
                </h2>
                <div id="conffile_auth" class="accordion-collapse show">
                  <div class="accordion-body bg-transparent">
                    <pre><code>
DavLockDB /var/www/DavLock
&lt;VirtualHost *:443&gt;
    ServerAdmin your_email_here
    ServerName your_ip_here
    DocumentRoot /var/www/html

    SSLCertificateFile /etc/ssl/zotero_webdav.crt
    SSLCertificateKeyFile /etc/ssl/zotero_webdav.key

    ErrorLog ${APACHE_LOG_DIR}/error.log
    CustomLog ${APACHE_LOG_DIR}/access.log combined

    Alias /webdav /var/www/webdav

    &lt;Directory /var/www/webdav&gt;
        DAV On
        AuthType Digest
	      AuthName "webdav"
	      AuthUserFile /etc/apache2/users.password
	      Require valid-user
    &lt;/Directory&gt;
&lt;/VirtualHost&gt;

&lt;VirtualHost *:80&gt;
    ServerName your_ip_here
    Redirect / https://your_ip_here/
&lt;/VirtualHost&gt;

# vim: syntax=apache ts=4 sw=4 sts=4 sr noet
                    </code></pre>
                  </div>
                </div>
              </div>
            </div>

            <p>TL;DR: make the changes to the configuration file as above, then run:</p>
            <div class="code-block"><code><ul>
              <li>sudo apt-get install apache2-utils</li>
              <li>sudo htdigest -c /etc/apache2/users.password webdav your_login_name_of_choice  # this will ask you to enter a password of choice twice</li>
              <li>sudo chown www-data:www-data /etc/apache2/users.password</li>
              <li>sudo a2enmod auth_digest</li>
              <li>sudo service apache2 restart</li>
            </ul></code></div>


            <h2 class="mt-5 mb-5"> 5. Setup Zotero</h2>

            <h4 class="mt-5 mb-5 ms-5">Configuring the settings</h4>
            <p>
              On the machine that runs Zotero (your laptop, workstation, etc.), open Zotero, and go to
              <code>Edit >> Preferences >> Sync</code>. On the "File Syncing" section, put these options:
            </p>
            <img class="mb-5 mt-3" style="width: 100%; max-width: 512px" alt="zotero-settings" src="resources/zotero_webdav.png">
            <p>Your username and password will be those defined in step 4. above.</p>

            <h4 class="mt-5 mb-5 ms-5">Whitelisting the self-signed SSL certificate</h4>
            <p>
              Zotero will not accept self-signed SSL certificates unless they are whitelisted, a process for which they do
              not yet have a GUI for, unfortunately. Here is the
              <a class="a-no-underline" target="_blank"
                 href="https://www.zotero.org/support/kb/cert_override">
                Zotero KB tutorial
              </a>
              for how to add the SSL certificate to the whitelist. Don't forget to strip the ":" from the
              <code>cert_override.txt</code> if you use the latest Mozilla Firefox version, as indicated in the note of the
              KB tutorial and
              <a class="a-no-underline" target="_blank"
                 href="https://forums.zotero.org/discussion/93200/zotero-seems-to-ignore-cert-override-txt-webdav-sync">
                this
              </a>
              error report.
            </p>
            <p>
              Unfortunately there is now way yet to automatize the whitelisting. So this will have to be re-done everytime
              the SSL certificate gets renewed. Also it must be done on every machine that runs Zotero (for which you want
              to use the synchronized library of course).
            </p>

          </div>
        </div>


        </p>
