        <div class="position-relative page-width-1 page-center">
          <div class="tm-bg-dark content-pad">
            <h1 class="mb-2">How to setup a Zotero webdav server</h1>
            <p>This is a first draft. Hopefully this will be finished off in the coming week. -- OC, 2021-11-29</p>
            <p>TODO some intro here to explain the motivation</p>

            <h2> 1. Setup the Raspberry Pi</h2>
            <div class="ms-4">
            <p>I won’t go into much detail about this as there are many comprehensive tutorials out there that already cover this.</p>

            <h4>Hardware</h4>
            <p>At first you will obviously need a screen, keyboard and mouse plugged into the Pi. Then, you can connect to your network (ethernet or wifi) and set up some remote-control software, such as VNC Viewer or SSH to control the Pi directly through a remote terminal. At this point you can essentially leave the Pi as such with just the power supply plugged, and the ethernet cable if you chose that method over wifi.</p>

            <h4>Basic Software</h4>

              <ul>
                <li>update to latest distro</li>
                <li>username</li>
                <li>firewall</li>
                <li>openssl</li>
                <li>apache2</li>
              </ul>
            <p>
              Next, we will need to setup and configure Apache on the Pi, which is a software that allows creating web servers.
            </p>
          </div>

            <h2> 2. Create a webdav server using the HTTP protocol</h2>
            <p>
              Follow this first but instead of using 000-default.conf we use our own virtualhost
              https://www.digitalocean.com/community/tutorials/how-to-configure-webdav-access-with-apache-on-ubuntu-14-04

              The virtual host is done according to step 5 of this
              https://www.digitalocean.com/community/tutorials/how-to-install-the-apache-web-server-on-ubuntu-20-04#step-5-%E2%80%94-setting-up-virtual-hosts-recommended

              the difference with the step 5 is that we use "webdav" as our domain to name /var/www/domain, we name the .conf file "webdav.conf" and put this in it:
            </p>
            <pre><code>
    DavLockDB /var/www/DavLock
    &lt;VirtualHost *:80&gt;
        ServerAdmin your_email_here
        DocumentRoot /var/www/html

        ErrorLog ${APACHE_LOG_DIR}/error.log
        CustomLog ${APACHE_LOG_DIR}/access.log combined

        Alias /webdav /var/www/webdav

        &lt;Directory /var/www/webdav&gt;
            DAV On
        &lt;/Directory&gt;
    &lt;/VirtualHost&gt;

    # vim: syntax=apache ts=4 sw=4 sts=4 sr noet
            </code></pre>


            <p>
              We also keep everything in www under www-data ownership
              And we don’t do this
              sudo chmod -R 755 /var/www/your_domain

              Then we enable (a2ensite) the DAV and the webdav.conf
              And we disable the 000-default.conf
              We can then check syntax. If we get the ServerName error we can ignore. If we want to fix it we can see here
              https://www.digitalocean.com/community/tutorials/apache-configuration-error-ah00558-could-not-reliably-determine-the-server-s-fully-qualified-domain-name
              Set the port forwarding to 80
              After restarting apache, we should be able to access the server online at
              	http://your_public_ip/webdav/
              We can then move on to making a https protocol
            </p>

            <h2> 3. Create a webdav server using the HTTPS protocol</h2>

            <h4>Configure the firewall</h4>
            <p>
              sudo ufw allow "Apache Full"
              sudo ufw delete allow "Apache"

              or
              sudo ufw allow "WWW Full"
              sudo ufw disable allow "WWW"

              enable a2enmod
              sudo a2enmod ssl
              sudo systemctl restart apache2
            </p>

            <h4>Edit the configuration file</h4>
            <p>and edit our webdav.conf file, so our file looks like this eventually</p>
            <pre><code>
    DavLockDB /var/www/DavLock
    &lt;VirtualHost *:443&gt;
        ServerAdmin codol.olivier@gmail.com
        ServerName your_public_ip
        DocumentRoot /var/www/html

        SSLCertificateFile /etc/ssl/zotero_webdav.crt
        SSLCertificateKeyFile /etc/ssl/zotero_webdav.key
        SSLCertificateChainFile /etc/ssl/zotero_webdav_ca_bundle.crt

        ErrorLog ${APACHE_LOG_DIR}/error.log
        CustomLog ${APACHE_LOG_DIR}/access.log combined

        Alias /webdav /var/www/webdav

        &lt;Directory /var/www/webdav&gt;
            DAV On
        &lt;/Directory&gt;
    &lt;/VirtualHost&gt;

    # vim: syntax=apache ts=4 sw=4 sts=4 sr noet
            </code></pre>
            <p>
              Note that on the second line, the virtual host is now 443 and not 80 anymore.
              Check syntax
              Reload apache2
            </p>

            <h4>Set up the port forwarding rule</h4>
            <p>
              Add a new port forwarding on your router for 443. Keep the 80 port for http re-routing later on (step 5)
              Now we need a SSL certificate for the HTTPS to actually work properly.
            </p>
            <h4>Get a SSL certificate for the webdav server</h4>
            <p>
              Get a SSL certificate from a Certificate Authority (CA), which is a third-party certificate provider. ZeroSSL is the only free CA I am aware of that accepts bare IP addresses:
              https://zerossl.com/
              You have to prove you own your website, and if you don’t want to do it using a DNS, they ask you to put a .txt file on your website at
              your_public_ip/.well-known/pki-validation/your_txt_file_here.txt
              since our DocumentRoot is set to <code>/var/www/html</code> on <code>webdav.conf</code>, this means we need to put the <code>.txt</code> file at:
            </p>
            <code>/var/www/html/.well-known/pki-validation/your_txt_file.txt</code>
            <p class="mt-3">Let’s first make the folders</p>
            <div class="code-block"><code>
              sudo mkdir /var/www/html/.well-known<br>
              sudo mkdir /var/www/html/.well-known/pki-validation<br>
              # just to ensure they are there<br>
              sudo mkdir /etc/ssl/certs/<br>
              sudo mkdir /etc/ssl/private/<br>
            </code></div>
            <p class="mt-3">
              Now there are two ways to proceed tp obtain a SSL certificate, manually or create an automatic renewal.
              The manual approach is not recommended because the certificates expire after a while, specifically a year
              or 90 days depending on what you chose when you request it.
              So you’re better off setting an automatic renewal to avoid redoing this every time your certificate expires.
              The reason the certificates are set to expire is the same reason as why we should change our password regularly,
              to ensure a more secure encryption over time.
              Consequently, 90-days certificate are better than 1-year certificates, which is great because they’re also
              the ones that Certificate Authorities (CAs) usually issue for free.
            </p>

            <h5>Manually request a SSL certificate</h5>
            <p>
              sudo cp ~/Downloads/your_txt_file.txt /var/www/html/.well-known/pki-validation/your_txt_file.txt

              Then you can download your certificate.
              https://help.zerossl.com/hc/en-us/articles/360058295854

              To install the certificate (source tutorial here), we put certificate.crt, private.key and ca_bundle.crt into my /etc/ssl/certs/, /etc/ssl/private/ and /etc/ssl/ directory, respectively, and rename them to match the .conf file:


              sudo cp ~/Downloads/certificate.crt /etc/ssl/certs/zotero_webdav.crt
              sudo cp ~/Downloads /private.key /etc/ssl/private/zotero_webdav.key
              sudo cp ~/Downloads/ca_bundle.crt/etc/ssl/private/zotero_webdav_ca_bundle.crt

              At this point you should be able to access your server online using the https protocol:
              https://your_ip_here
            </p>

            <h5>Automatically request a SSL certificate</h5>
            <p>
              What I mean by "automatically" is that we will use a script to request the SSL certificate and make this
              script run automatically upon its expiration.

              There are a lot of APIs that allows to do exactly that with no more than a couple command lines.
              Now here is the problem: most of them rely on either the ACME (link) or Certbot (link) packages, which are
              used not only by ZeroSSL, but also other CAs (notably "Let’s Encrypt" LINK). These other CAs do NOT
              provide certificates for bare IP addresses the way ZeroSSL does. So we cannot use them to ask for a new
              certificate each time. The solution is to use the raw API provided directly by ZeroSSL (link), write a
              shell script that handles everything for us, and finally automate the call of that script using a CRON job
              on the server. And here the magic of the internet comes into full swing: someone had that exact problem
              and shared the shell script for that purpose
              (https://blog.thestateofme.com/2021/04/02/zerossl-api-the-missing-examples/) (https://gist.github.com/cpswan/a955ab86d6e469029edc65c362ce72dd)
              Obviously this isn’t <em>exactly</em> what we want, but it’s pretty damn close.
            </p>
            <p>
              Here you can download an amended version that will fit the purpose of our server.
              <strong>Please change the ZeroSSL key and your domain in the script for it to work at all.</strong>
                (link to show where to find the key). To get the account key you should create an account with ZeroSSL
              Please put them in a place where you have write access (I put mine in ~/Documents/renew-ssl/).
              We’ll also need some dependencies
            </p>
            <code>sudo apt-get install openssl python3 jq curl</code>
            <p class="mt-3">Then run the script using the path you chose</p>
            <code>sh /your/path/to/renew-ssl.sh</code>
            <p class="mt-3">For instance for my chosen path it would be like this</p>
            <code>sh ~/Documents/renew-ssl/renew-ssl.sh</code>
            <p class="mt-3">If the script goes without errors, you should have your website SSL-certified now. Congrats!</p>
            <p>
              Now let’s set up a CRON job to make this automatic.

              #write out current crontab
              cd ~/Documents
              sudo crontab -l > mycron

              #echo new cron into cron file
              echo "01 00 * * * test $(( `date +\%s`/86400%90 )) = 0 && sudo sh /your/path/to/renew-ssl.sh" >> mycron

              #install new cron file
              sudo crontab mycron
              rm mycron

              Done!
            </p>

            <h4>HTTP => HTTPS transfer</h4>
            <p>
              Now to be able to access the website at https with the http address, add this at the bottom of webdav.conf (before the last line):
            </p>
            <pre><code>
    &lt;VirtualHost *:80&gt;
        ServerName your_public_ip
        Redirect / https://your_public_ip/
    &lt;/VirtualHost&gt;
            </code></pre>
            <p>
              Then run in a terminal
              sudo apachectl configtest
              sudo systemctl reload apache2

              Then you can test this online by connecting to your website with either http or https
            </p>

            <h4>Adding authentication</h4>
            <p>
              Do step 3 of this tutorial
              https://www.digitalocean.com/community/tutorials/how-to-configure-webdav-access-with-apache-on-ubuntu-14-04
            </p>

          </div>
        </div>
